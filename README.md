# Плюсы
## 1. Директивы препроцессора (`#include`, `#define`). Функция main()

Препроцессор запускается до компилятора и преобразовывает исходный код в код, который видит компилятор. Каждая строка, которая начинается с #, представляет собой директиву препроцессора.
`#include` директива указывает, что код должен включить содержимое какого-то файла в исходный текст вместо самой директивы. Для стандартных заголовочных файлов используются `<>`, для других `""`.
Примеры: 
  ```cpp
 #include <iostream>
#include "tracer.h"
 ```
`#define` директива выполняет определяет макропостановки, которые будет проводить препроцессор.
Например, написав `#define abc xyz` компилятор вместо исходного кода:
```cpp
int abc = 1;
int abcd = 2;
```

Увидит:
```cpp
int xyz = 1;
int abcd = 2;
```
Слово, на которое будет выполнена замена - это макрос. Макросы принято писать uppercase-ом.
Также с помощью define можно определить макросы с параметрами.
```cpp
// пример макроса, который определяет максимум 2 объектов.
#define MAX(x, y) ( ((x) > (y)) ? (x) : (y) ) 
```

Все программы, написанные на С++, должны содержать функцию с именем `main()`. Ей дается управление после запуска программы. Она может возвращать значения в вызвавшую систему. Функция `main()` может быть без параметров и с параметрами:
```cpp
int main();
int main(int argc, char* argv[]);
```

## 2. Встроенные типы данных. Строки std::string и массивы std::vector
 Каждая переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная, 
 какие операции с ней можно производить и сколько байт в памяти она будет занимать.
 В языке C++ определены следующие базовые типы данных:
+ логический (bool)
+ символьный (char), 
+ целочисленный (int, unsigned int), 
+ вещественный (double, float)  
---
 С помощью них можно реализовать все идеи и создавать собственные типы. `std::string` - массив символов хранящий свой размер и имеющий свои методы,
 `std::vector` - массив содержащий элементы одного типа данных, хранящий свой размер и  имющий свои методы.

## 3. Константы. Квалификаторы `const` и `constexpr`
Квалификаторы `const` и `constexpr` говорят о том, что значения хранящиеся в памяти под этим именем именять нельзя. 
значние с квалификатором constexpr - обязано быть известно на этапе компиляции, а вот const - нет.
```cpp
const a = 12; // может быть и не известна во время компиляции
constexpr b = 15; // должна быть известна во время компиляции
```

## 4. Арифметические и логические операторы. Операции с присваиванием. Приоритет
С++ поддерживает арифметические операторы `+`, `-`, `*`, `/`, `%` (определен только для целочисленных типов)  
     Деление по умолчанию целочисленное, если оба параметра целочисленные, и дробное, если хотя бы один параметр нецелочисленный. Операторы `+` и `-` так же могут быть унарными. Существуют так
     же операторы с присваиванием, как то `+=`, `-=`, `*=`, `/=`. Операторы декремента `--` и инкремента `++` бывают двух типов - постфиксный, который возвращает значение до изменения (которое
     является r-value!!!), и префиксный, возвращающий значение после его изменения (и оно l-value).
     Логические операторы - `<`, `<=`, `>`, `>=`, `!(отрицание)`, `!=` и `==`.
     Приоритет операций - самый низкий у присваивающих, потом `+` и `-`, потом `%`, потом `++` и `—`, потом `*` и `/`. Логические операторы имеют приоритет ниже, чем арифметические.  
     Важно: при перегрузке арифметических операторов нужно, чтобы оператор возвращал r-value ссылку на объект , к которому применен оператор (или просто его копию).
     Это необходимо для того, чтобы, например, запись `if (i + i > j)` была корректной.
     При перегрузке оператора= нужно возвращать ссылку на объект, чтобы запись `std::cout << e = 5;` была корректна.
     
## 7. Оператор `throw` и блоки `try-catch`
Данные конструкции нужны для обработки ошибок, возникающих при работе кода (runtime-errors). Код, в котором могут возникнуть ошибки времени исполнения (практически любой код :laughing:)
Есть два типа исключений: сгенерированые нами и сгенерированные самим кодом. Для генерации исключения необходимо использовать ключевое слово `throw`:
```cpp
if (n < 0) throw std::runtime_error("Значение не может быть отрицательным");

```
Мы создали исключение, но никак его не обработали. Для обрабокт исключений необходим блок `try-catch`
```cpp
try 
{
    int n = -10;
    // Здесь помещаем код, в котором могут быть runtime-errors
    if (n < 0) throw std::runtime_error("Значение не может быть отрицательным");
  
}
catch (std::exception& e)
{
    // здесь мы перехватываем исключение и выводим сообщение об ошибке
    std::cerr << e.what() << std::endl;
}
```
Обратите внимание на выражение `e.what()` - оно позволяет получить сроку с информацией об ошибке.

Вообще, есть стандартная конструкция для обработки ошибок, которую я вижу во всех программах, где ошибки хоть как-то обрабатываются:
```cpp
int main()
try
{
  
}
catch (std::exception& e) {
    std::cout << e.what() << std::endl;
    return 1;
}
catch (...) {
std::cout << "Commander, we need more rockets" << std::endl;
return 2;
}
```

## 11. Функции. Прототип и определение. Возвращаемое значение. Формальные и фактические параметры. `constxepr`-функции

## 12 Классы. Поля́ и методы. Части класса. Указатель `this`. Деструктор
Классы - это пользовательские типы в `С++`. Классы объявляются за границей функций. Для объявления класса есть 2 ключевых слова - `struct` и `class`. Синтаксис следующий:
```cpp
class MyClass{
public:
//code
private:
//code
protected:
//code
};
```
Разница в `struct` и `class`состоит только лишь в том, что в `class` все поля по умолчанию `private`, а в `struct` - `public`. То есть запись
```cpp
class Myclass{
private:
int int1;
public:
int int2;
};
```
полностью эквивалентна
```cpp
class Myclass{

int int1;
public:
int int2;
};
```

Точка с запятой в конце объявления класса обязательна. В классе есть 3 раздела - `public:`, `private:` и `protected:`. Члены класса, записанные после метки `public`, являются публичными
и доступны к обращению извне класса: `obj.field`. Поля после метки `private` доступны только изнутри класса, то есть только в его методах. Пользователь класса к этим членам обратиться не может.
Поле `protected` - поле, которое доступно только дочерним классам, в отличие от полей `private`, которые дочерним классам недоступны.

Если в классе объялвен метод, название которого совпадает с названием класса, то такой метод называется конструктором. Конструктор не имеет возвращаемого значения!
Метод, название которого совпадает с названием класса, но начинается с `~`, называется деструктором:
```cpp
class MyClass{
public:
MyClass(); //Конструктор
~Myclass(); //Деструктор
};
```
Согласно `RAII`, если объект запросил ресурсы в конструкторе, то он должен их вернуть в деструкторе.

Если необходимо получить доступ к объекту, из которого вызван метод класса, используется ключевое слово `this`, которое является указателем этот самый объект. Для него доступны операции
разыменовывания `*` и обращения к полям через `->`.

## 15. Чтение и запись файлов. Настройка (формата) ввода-вывода. Позиционирование в файле

## 16 Перегрузка оператора вызова и функциональные объекты. Лямбда-выражения.
При объявлении класса есть возможность перегрузить `operator()`, получив таким образом функциональный объект - `функтор` - то есть класс, объекты которого могут вести себя как функции с точки зрения пользователя.
Это может быть удобно для сохранения каких-либо данных - например, про количество вызванных таким образом операторов()
```cpp
class MyClass{
public:
MyClass() {}
static int counter;
int operator()(int a, int b) {
++counter;
return a+b;
}

};
int MyClass::counter = 0;

int main(){
MyClass summ1;
MyClass summ2;
cout « summ1(2, 5) + summ2(1, 4);
}
```
Выведено будет 12, и `summ1.counter == summ2.counter == MyClass::counter == 2`

`Лямбда - выражения` - это анонимные функции. Синтаксис следующий:
```cpp
[`захваченные снаружи переменные`](`параметры лямбда - функции`) {`тело функции`}
```

Лямбды могут применяться, например, для передачи в функции:
```cpp
...
struct T{
T() {}
int field {0};
};
...
int n = 9;
bool is_raise = false;
std::vector<T> vec(n)
...
std::sort(vec.begin(), vec.end(), [flag](const T& a, const T& b){
if(flag) return a.field > b.field;
else return a.field < b.field;
})
...
```
Таком образом можно отсортировать вектор так, как нам необходимо, даже если `operator<` у класса `T` не перегружен.

## 19. Стиль оформления программ. Правила "хорошего тона"

## 20 Этапы и средства разработки программ.

Процесс разработки программ можно разделить на четыре этапа.
• `Анализ`. В чем заключается задача? Чего хочет пользователь? Что требуется пользователю? Что может позволить себе пользователь? Какая степень надежности нам необходима?
• `Проектирование`. Как решить задачу? Какую структуру должна иметь система? Из каких частей она должна состоять? Каким образом эти части будут взаимодействовать? Каким образом система будет взаимодействовать с пользователем?
• `Программирование`. Выражение решения задачи (проекта) в исходном тексте. Написание программы с учетом всех установленных ограничений (по времени, объему. финансам, надежности и т.д.).
Проверка. что программа работает правильно и удобна в сопровождении.
• `Тестирование`. Проверка. что во всех предусмотренных ситуациях система работает правильно. (очень важный этап. Даже если вам кажется, что все написано верно, не поленитесь и протестируйте все возможные паттерны поведения, а не только наиболее вероятные.)