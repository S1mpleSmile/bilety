# Плюсы

> Над проектом трудятся: Шарипов Тимур, Осипян Арсен, Рубченко Павел, Иванов Александр, Фатин Данила

## :warning: Work in progress :construction: :construction_worker:
- [x] 1
- [x] 2
- [x] 3
- [x] 4
- [x] 5
- [x] 6
- [x] 7
- [ ] 8
- [x] 9
- [x] 10
- [ ] 11
- [x] 12
- [x] 13
- [x] 14
- [ ] 15
- [x] 16
- [x] 17
- [x] 18
- [ ] 19
- [x] 20
- [x] 21
- [ ] 22
- [ ] 23
- [ ] 24

## 1. Директивы препроцессора (`#include`, `#define`). Функция main()

Препроцессор запускается до компилятора и преобразовывает исходный код в код, который видит компилятор. Каждая строка, которая начинается с #, представляет собой директиву препроцессора.
`#include` директива указывает, что код должен включить содержимое какого-то файла в исходный текст вместо самой директивы. Для стандартных заголовочных файлов используются `<>`, для других `""`.
Примеры: 
```cpp
#include <iostream>
#include "tracer.h"
```
`#define` директива выполняет определяет макропостановки, которые будет проводить препроцессор.
Например, написав `#define abc xyz` компилятор вместо исходного кода:
```cpp
int abc = 1;
int abcd = 2;
```

Увидит:
```cpp
int xyz = 1;
int abcd = 2;
```
Слово, на которое будет выполнена замена - это макрос. Макросы принято писать uppercase-ом.
Также с помощью define можно определить макросы с параметрами.
```cpp
// пример макроса, который определяет максимум 2 объектов.
#define MAX(x, y) ( ((x) > (y)) ? (x) : (y) ) 
```

Все программы, написанные на С++, должны содержать функцию с именем `main()`. Ей дается управление после запуска программы. Она может возвращать значения в вызвавшую систему. Функция `main()` может быть без параметров и с параметрами:
```cpp
int main();
int main(int argc, char* argv[]);
```

## 2. Встроенные типы данных. Строки std::string и массивы std::vector
Каждая переменная имеет определенный тип. И этот тип определяет, какие значения может иметь переменная, какие операции с ней можно производить и сколько байт в памяти она будет занимать.
В языке C++ определены следующие базовые типы данных:
+ логический (bool)
+ символьный (char), 
+ целочисленный (int, unsigned int), 
+ вещественный (double, float)
С помощью них можно реализовать все идеи и создавать собственные типы. `std::string` - массив символов хранящий свой размер и имеющий свои методы,
`std::vector` - массив содержащий элементы одного типа данных, хранящий свой размер и  имющий свои методы.

## 3. Константы. Квалификаторы `const` и `constexpr`
Квалификаторы `const` и `constexpr` говорят о том, что значения хранящиеся в памяти под этим именем именять нельзя. 
значние с квалификатором constexpr - обязано быть известно на этапе компиляции, а вот const - нет.
```cpp
const a = 12; // может быть и не известна во время компиляции
constexpr b = 15; // должна быть известна во время компиляции
```

## 4. Арифметические и логические операторы. Операции с присваиванием. Приоритет
С++ поддерживает арифметические операторы `+`, `-`, `*`, `/`, `%` (определен только для целочисленных типов)  
     Деление по умолчанию целочисленное, если оба параметра целочисленные, и дробное, если хотя бы один параметр нецелочисленный. Операторы `+` и `-` так же могут быть унарными. Существуют так
     же операторы с присваиванием, как то `+=`, `-=`, `*=`, `/=`. Операторы декремента `--` и инкремента `++` бывают двух типов - постфиксный, который возвращает значение до изменения (которое
     является r-value!!!), и префиксный, возвращающий значение после его изменения (и оно l-value).
     Логические операторы - `<`, `<=`, `>`, `>=`, `!(отрицание)`, `!=` и `==`.
     Приоритет операций - самый низкий у присваивающих, потом `+` и `-`, потом `%`, потом `++` и `—`, потом `*` и `/`. Логические операторы имеют приоритет ниже, чем арифметические.  
     Важно: при перегрузке арифметических операторов нужно, чтобы оператор возвращал r-value ссылку на объект , к которому применен оператор (или просто его копию).
     Это необходимо для того, чтобы, например, запись `if (i + i > j)` была корректной.
     При перегрузке оператора= нужно возвращать ссылку на объект, чтобы запись `std::cout << e = 5;` была корректна.
     
## 5. Операторы ветвления if-else и switch. Конструкция else-if
Операторы ветвления нужны в случае, когда код должен работать по разному в зависимости от каких-либо условий.
Синтаксис `if-else`:
```cpp
if (condition1) {
  // code ...
}
else if (condition2) {
  // code ...
}
else {
  // code ...
}
```
Преимущества `if-else` по сравнению с `switch`:
+ работает с любыми условиями
Синтаксис switch:
```cpp
switch (expression) {
  case val1: // code ...
  case val2: // code ...
  default:   // code ...
}
```
Правила `switch`:
+ работает с перечислениями, `char` и `int`
+ значения меток `case` - константные выражения
+ метки имеют уникальные значения
+ метка должна завершаться ключевым словом `break`, чтобы не перейти к выполнению кода следующего блока `case`
Преимущества switch по сравнению с `if-else`:
+ работает быстрее    

## 6. Операторы цикла: `while`, `do-while`, `for`. Операторы `break`, `continue`
 Для многократного повторения действий предусмотрена итерация(циклы):
```cpp
   int i = 0;

   while(i < 100) //условие цикла, проверяющее значение счетчика
   {
	++i  // тело цикла, выполнение которого будет повторяться
   }
   for (int i = 0; i < 100; ++i) { }

    do
    { 
    // гарантированно выполнит как минимум одну итерацию (делает, потом проверяет)
    }
    while() 
```

##### Операторы break и continue:
* В контексте оператора switch оператор break обычно используется в конце каждого кейса для его завершения (предотвращая fall-through).
* В контексте циклов оператор break используется для завершения работы цикла раньше времени.
* Оператор continue позволяет сразу перейти в конец тела цикла, пропуская весь код, который находится под ним.
---
 Это полезно в тех случаях, когда мы хотим завершить текущую итерацию раньше времени.

## 7. Оператор `throw` и блоки `try-catch`
Данные конструкции нужны для обработки ошибок, возникающих при работе кода (runtime-errors). Код, в котором могут возникнуть ошибки времени исполнения (практически любой код :laughing:)
Есть два типа исключений: сгенерированые нами и сгенерированные кодом. Для генерации исключения необходимо использовать ключевое слово `throw`:
```cpp
if (n < 0) throw std::runtime_error("Значение не может быть отрицательным");

```
Мы создали исключение, но никак его не обработали. Для обработки исключений необходим блок `try-catch`:
```cpp
try 
{
    // Здесь помещаем код, в котором могут быть runtime-errors

    int n = -10;
    if (n < 0) throw std::runtime_error("Значение не может быть отрицательным");
  
}
catch (std::exception& e)
{
    // Здесь перехватываем исключение и выводим сообщение об ошибке
    std::cerr << e.what() << std::endl;
}
```
Обратите внимание на выражение `e.what()` - оно позволяет получить строку с информацией об ошибке.

Вообще, есть стандартная конструкция для обработки ошибок, которую я вижу во всех программах, где ошибки хоть как-то обрабатываются:
```cpp
int main()
try
{
  
}
catch (std::exception& e) {

    std::cout << e.what() << std::endl;

    return 1;
}
catch (...) {

std::cout << "Commander, we need more rockets" << std::endl;

return 2;
}
```
Выражение `catch(...)` перехватывает все типы ошибок. То есть, если ошибка не была поймана в `catch (std::exception& e)`, она обязательно попадет в блок с `catch(...)`

## 9. Динамическое выделение памяти. Операторы new-delete и new[]-delete[]
С помощью оператора new (`new[]` для массивов) выделяется память из динамической памяти (или кучи), а с помощью delete (`delete[]` для массивов) - освобождается.
Оператор new выполняет выделение динамической памяти:
+ возвращает указатель на выделенную память (адрес первого байта выделенной памяти)
+ указатель указывает на объект определенного типа
+ указатель не знает количество элементов, на которые он указывает
```cpp
int* pi = new int; // one element
int* qi = new int[10]; // array
```
Написав `int* pi = new int[5];` мы получим указатель `pi`, который указывает на первый элемент массива целочисленных значений:
```cpp
pi:[...]
   /
[...][...][...][...][...]
```
Для того, чтобы найти нужный элемент с помощью оператора `[]` используется информация о размере типа, поэтому нельзя присвоить указателю на один тип указатель на другой тип.
Основная проблема работы с указателями: указатель не знает, на какое количество элементов он указывает. Из-за этого может возникнуть выход за пределы диапазона.
При работе с динамической памятью через `new-delete` лучше пользоваться правилом: "На каждый `new` нужен свой `delete`". Это позволит избежать утечек памяти.
В процессе работы может возникнуть грубая ошибка - двойное удаление памяти.
Оператор new сначала выделяет память, а затем вызывает конструктор(-ы) нужного типа, оператор delete вызывает деструктор(-ы), а потом освобождает память.

## 10. Массивы: одномерные и многомерные. Строки символов в стиле C
Массив - это однородный, упорядоченный структурированный тип данных с прямым доступом к элементам.  
Элементы массива объединяются общим именем и занимают в компьютере определенную конечную область памяти.  
К любому элементу массива можно обратиться, указав имя массива и индекс элемента в массиве `int a[7]`
Массивы с двумя индексами называют двумерными `int b[3][4]`
Такие массивы можно представить в виде таблицы, в которой номер строки соответствует первому индексу,
а номер ячейки в строке (номер столбца) - второму индексу.
Строка в стиле Cи представляет собой массив символов, заканчивающийся нулевым символом ( так называемый, терминальный ноль `'\0'` ) :
```cpp
char str[100]; char st[] = "tratata eto stroka";
```




## 12 Классы. Поля и методы. Части класса. Указатель `this`. Деструктор.
Классы - это пользовательские типы в `С++`. Классы объявляются за границей функций. Для объявления класса есть 2 ключевых слова - `struct` и `class`. Синтаксис следующий:
```cpp
class MyClass {
public:
    //code
private:
    //code
protected:
    //code
};
```
Разница в `struct` и `class`состоит только лишь в том, что в `class` все поля по умолчанию `private`, а в `struct` - `public`. То есть запись
```cpp
class Myclass {
private:
    int int1;
public:
    int int2;
};
```
полностью эквивалентна
```cpp
class Myclass {
    int int1;

public:
    int int2;
};
```

Точка с запятой в конце объявления класса обязательна. В классе есть 3 раздела - `public:`, `private:` и `protected:`. Члены класса, записанные после метки `public`, являются публичными
и доступны к обращению извне класса: `obj.field`. Поля после метки `private` доступны только изнутри класса, то есть только в его методах. Пользователь класса к этим членам обратиться не может.
Поле `protected` - поле, которое доступно только дочерним классам, в отличие от полей `private`, которые дочерним классам недоступны.

Если в классе объялвен метод, название которого совпадает с названием класса, то такой метод называется конструктором. Конструктор не имеет возвращаемого значения!
Метод, название которого совпадает с названием класса, но начинается с `~`, называется деструктором:
```cpp
class MyClass {
public:
    MyClass(); //Конструктор
    ~Myclass(); //Деструктор
};
```
Согласно `RAII`, если объект запросил ресурсы в конструкторе, то он должен их вернуть в деструкторе.

Если необходимо получить доступ к объекту, из которого вызван метод класса, используется ключевое слово `this`, которое является указателем этот самый объект. Для него доступны операции
разыменовывания `*` и обращения к полям через `->`

## 13. Перечисления enum class и "простые" перечисления
Перечисление - простой пользовательский тип, задающий множество значений в виде символических констант. Каждому значению Month имеет эквивалентное целочисленное значение. Каждому элементу можно задать определенное значение, можно задать значение первого элемента (тогда каждому элементу будет присвоено значение предыдущего, увеличенное на единицу), можно вообще не задавать значений, тогда отсчет начнется с нуля.
Пример:
```cpp
enum class Color
{
  red, yellow, green, blue, brown, black, white
}
```
Ключевое слово `class` означает, что элементы находятся в области видимости перечисления, то есть доступ к ним происходит через указание имени области видимости (например, `Color::white`). Отсутствие `class` означает, что элементы не будут находиться в текущей области видимости, а не в области видимости перечисления. Такие перечисления называются "простыми". Элементы простых перечислений могут быть неявно преобразованы в `int`. Простые перечисления могут загрязнять область видимости.
Применение перечислений:
```cpp
enum class Color { white /*, etc*/ }
//...
Color c = Colot::white;
```

## 14. Перегрузка операторов.   
Перегрузка операторов - для класса или перечисления можно определить все операторы,
 существующие в языке C++: `+`, `-`, `*`, `/`, `%`, `[]`, `()`, `^`, `!`, `&`, `<`, `<=`, `>=` и др  ).
 Применяется, когда требуется сохранить привычные обозначения для
 разрабатываемого нами типа. Рассмотрим пример:
```cpp
  enum class Month {
    Jan = 1, Feb, Mar, Apr, May, Jul, Aug, Sep, Oct, Nov, Dec
 };
 
 Month operator++ (Month& m){ //перегрузка оператора ++
   m = (m == Dec)?Jan:Month(int(m)+1);
   return m;
 }

 vector<string> month_tbl = {"", "Jan", "Feb", ... "Dec"};
 ostream& operator<<(ostream& os, Month m) { //перегрузка оператора <<
   return os << month_tbl[int(m)];
 }
```

## 16. Перегрузка оператора вызова и функциональные объекты. Лямбда-выражения.
При объявлении класса есть возможность перегрузить `operator()`, получив таким образом функциональный объект - `функтор` - то есть класс, объекты которого могут вести себя как функции с точки зрения пользователя.
Это может быть удобно для сохранения каких-либо данных - например, про количество вызванных таким образом операторов()
```cpp
class MyClass {
public:
    MyClass() {}
    static int counter;
    int operator()(int a, int b) {
    ++counter;
    return a + b;
}

};

int MyClass::counter = 0;

int main() {
    MyClass summ1;
    MyClass summ2;
    cout << summ1(2, 5) + summ2(1, 4);
}
```
Выведено будет 12, и `summ1.counter == summ2.counter == MyClass::counter == 2`

`Лямбда - выражения` - это анонимные функции. Синтаксис следующий:
```cpp
[`захваченные снаружи переменные`](`параметры лямбда - функции`) {`тело функции`}
```

Лямбды могут применяться, например, для передачи в функции:
```cpp
...
struct T {
    T() {}
    int field {0};
};
...
int n = 9;
bool is_raise = false;
std::vector<T> vec(n)
...
std::sort(vec.begin(), vec.end(), [flag](const T& a, const T& b){
if(flag) return a.field > b.field;
else return a.field < b.field;
})
...
```
Таком образом можно отсортировать вектор так, как нам необходимо, даже если `operator<` у класса `T` не перегружен.

## 17. Наследование. Ключевые слова virtual и override
Наследование - один из основополагающих принципоп парадигмы объектно-ориентированного программирования. Благодаря наследованию можно избежать дублирования кода, к тому наследование помогает логически организовать код. Класс, от которого происходит наследование, называется "родительским" ("суперклассом", "базовым"), а класс, который наследует - "дочерний" ("подкласс", "производный").
Синтаксис наследования:
```cpp
class sub_class : <inheritance_type> super_class
{ ... }
```
Типы наследования:
+ `public` (уровень доступа к данным не меняется)
+ `protected` (`public` становится protected, остальное не меняется)
+ `private` (все унаследованные данные становятся `private`)
Виртуальные функции - функции родительского и дочернего класса с одинаковыми именами, возвращаемыми типами и типами аргументов. Эта возможность позволяет реализовать полиморфизм времени выполнения (или, по-другому, динамическая диспетчеризация). Для обработки виртуальных функций классу требуются `vtbl` (таблица виртуальных функций) и vptr (указатель на `vtbl`). При вызове метода для объекта x какого-то класса код перейдет через таблицу виртуальных функций к нужной функции для вызова.
```cpp
virtual void do_something ();
```
Создается виртуальная функция с помощью спецификатора `virtual`. Виртуальную функцию может переопределить дочерний класс.
Абстрактный класс - класс, который можно использовать только в качестве родительского.
Сделать класс абстрактным можно созданием чисто-виртуальной функции (функции, которыми должны быть определены в дочерних классах).
```cpp
virtual void do_something () = 0;
```
Для указания того, что функция должна перекрывать виртуальную функцию базового класса, используется ключевое слово `override`.
Пример:
```cpp
class Enemy
{
virtual void attack () = 0;
virtual void run () { /*code*/ };
};
class Soldier : public Enemy
{
void attack () override { /*code*/ };
void run () override { /*code*/ }
};
```

## 18. Шаблонные функции и классы.
По существу, шаблон (template) - это механизм, позволяющий программисту
 использовать типы в качестве параметров класса или функции. Получив эти
 аргументы, компилятор генерирует конкретный класс или функцию.
 ```cpp
 //почти реальны вектор элементов типа Т
  template<typename T> class vector{
   // читается как "для всех типов Т"
   int sz;
   T* elem; // указатель на элементы
   // ...
   };
   
   template<typename T>
   void vector<T>::push_back(const T& d) {/*.../*};
```
Вариант шаблона для конкретного набора шаблонных аргументов называется
специализацией. Процесс генерации специализаций на основе шаблона 
и набора аргументов называется инстанцированием шаблона.
```cpp
  template<typename T>
   struct Compare {		//обобщенное сравнение
	bool operator() (const T& a, const T& b) const
	{
		return a<b;
	}
   };
   template<>
   struct Compare<const char*> {	//Сравнение C-строк
	bool operator() (const char* a, const char* b) const
	{
		return strcmp(a,b) < 0;
	}
  };
```

## 20. Этапы и средства разработки программ.

Процесс разработки программ можно разделить на четыре этапа.
• `Анализ`. В чем заключается задача? Чего хочет пользователь? Что требуется пользователю? Что может позволить себе пользователь? Какая степень надежности нам необходима?
• `Проектирование`. Как решить задачу? Какую структуру должна иметь система? Из каких частей она должна состоять? Каким образом эти части будут взаимодействовать? Каким образом система будет взаимодействовать с пользователем?
• `Программирование`. Выражение решения задачи (проекта) в исходном тексте. Написание программы с учетом всех установленных ограничений (по времени, объему. финансам, надежности и т.д.).
Проверка. что программа работает правильно и удобна в сопровождении.
• `Тестирование`. Проверка. что во всех предусмотренных ситуациях система работает правильно. (очень важный этап. Даже если вам кажется, что все написано верно, не поленитесь и протестируйте все возможные паттерны поведения, а не только наиболее вероятные.)

## 21. Обработка ошибок. Возможные альтернативы. Механизм исключений
Классификация ошибок:
+ ошибки времени компиляции (`compilation errors`): синтаксические ошибки, ошибки типов и тд
+ ошибки времени выполнения (`run time errors`): ошибки, обнаруженные компьютером, библиотекой или кодом пользователя
+ ошибки времени редактирования связей: ошибки при попытке объединения объектных файлов в выполнимый модуль
+ логические ошибки (`logic errors`)
Случаи, в которым можно не обрабатывать ошибки:
+ ошибки аппаратного обеспечения, операционной системы
+ нет возможности изменить определение функции
+ пользователю нужно знать об ошибки, что предпринять какие-либо действия
+ значительное уменьшение производительности в случае обработки
Две альтернативы обработки ошибок:
+ обработка в вызывающем коде (непрактично, кроме случая, когда нет доступа к изменению вызываемого кода, то есть добавления обработки; может привести к дублированию кода, его нечитаемости)
+ обработка в вызываемом коде (логичный выход; в некоторых случаях невозможно реализовать)
Механизм исключений (реализуется с помощью try, catch и throw). Основная идея: отделение кода, который может генерировать исключения, от кода, обрабатывающего эти исключения.
Синтаксис:
```cpp
try {
  // код ... 
}
catch (/*тип ошибки или "..." для любых случаев*/) {
  // обработка ошибки ...
}
```
Может быть несколько блоков `catch` для разных типов.
Обычно в блоке `catch`:
 - выводится сообщение об ошибке
 - исключение отправляется "выше", в другой блок `try-catch`
Исключения генерируются с помощью оператора `throw`
```cpp
throw std::runtime_error{"error"};
throw "error";
throw -1;
```

## 22. Способы организации структуры и взаимодействия в программе:
### 22.2. Функции. Механизм вызова, организация стека активационных записей. Рекурсия
Функция - фрагмент программного кода, к которому можно обратиться из другого места программы. В языке C++ допускаются именованные и безымянные (`lambda`) функции. После выполнения функции управление возвращается обратно в адрес вызова - точку программы, откуда данная функция была вызвана.
При вызове функции реализация ЯПа создает структуру данных, содержащую копии всех ее параметров и локальных переменных.
Например, вызывая функцию:
```cpp
int sum (int a, int b)
{
  int res = a + b;
  return res;
}
```
Компилятор создаст структуру (запись активации функции), хранящую в себе `a`, `b` и `res`, а также детали реализации, которые варьируются от компилятора к компилятору.
С точки зрения реализации параметр представляет собой всего лишь одну из локальных переменных.
Вывозвы функций хранятся в стеке. Вызовы обрабатываются по принципу (последний добавился - первый вышел). То есть при добавлении вызова функции в стек вызовов, сначала обработается вызванная функция, а затем программа вернется к месту вызова. Такой стек называется стеком записей активации (или стек вызовов).
Рекурсия - вызов функции в самой функции. Ввиду существования рекурсии был существует и рекурсивный подход - использование рекурсии в алгоритмах.
Пример рекурсии:
```cpp
int pow (int a, int n)
{
  if (n == 1)
    return a;
  else
    return a * pow(a, n-1);
}
```
Во время написания рекурсивных функций надо продумать правильное условия выхода, иначе рекурсия может стать бесконечной.

### 22.3. Способы передачи параметров в функцию
Существуют разные способы передачи параметров в функцию:
+ Передача копированием (`int f (int f);`). Используется для базовых или маловесных типов. При передаче массивных данных следует использовать один из 2 следующих типов.
+ Передача по ссылке (`int multiple (std::vector<int>& v, int a);`). Используется в случае, если переданную переменную нужно изменить.
+ Передача по константной ссылке (`int sum (cosnt std::vector<int>& v);`). Используется для оптимизации по памяти, чтобы исключить копирование. Причем лучше использовать именно константную сслылку, если нет надобности изменять данные.
+ Передача функции (`double integral (double (*f)(double));`, или `double integral (double (f)(double));`, или `double integral (double f(double));`). Случаи использования очевидны.



